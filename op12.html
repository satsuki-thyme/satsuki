<html lang="ja-JP" class="top-page">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>op12 レオンの冒険の腕前</title>
<meta name="keywords" content="レオンの冒険の腕前, 小説, ライトノベル, ラノベ, 長編, ファンタジー">
<meta name="description" content="長編ファンタジー小説「レオンの冒険の腕前」を書き上がったところから随時公開しています。">
<meta property="og:url" content="https://satsuki.me/op12.html">
<meta property="og:title" content="op12 レオンの冒険の腕前">
<meta property="og:description" content="長編ファンタジー小説「レオンの冒険の腕前」を書き上がったところから随時公開しています。">
<meta property="og:image" content="https://satsuki.me/images/op12-sign-board-1200x630.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:site_name" content="五月タイムのサイト">
<meta property="og:type" content="webpage">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@SatsukiThyme">
<meta name="twitter:site" content="@satsuki_thyme">
<meta name="twitter:image:src" content="https://satsuki.me/images/op12-sign-board-1200x630.png">
<meta name="msapplication-square70x70logo" content="https://satsuki.me/images/thyme-fg-white-bg-green-70s.png">
<meta name="msapplication-square150x150logo" content="https://satsuki.me/images/thyme-fg-white-bg-green-150s.png">
<meta name="msapplication-wide310x150logo" content="https://satsuki.me/images/thyme-fg-white-bg-green-310x150.png">
<meta name="msapplication-square310x310logo" content="https://satsuki.me/images/thyme-fg-white-bg-green-310s.png">
<meta name="msapplication-TileColor" content="#62a433">
<link rel="icon" href="https://satsuki.me/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="https://satsuki.me/images/thyme-fg-white-bg-green-180s.png">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-168979993-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-168979993-1');
</script>
<script>
/*

  変数

*/
let linkBase = "https://satsuki.me/op12.html"
let backhost = "https://raw.githubusercontent.com/satsuki-thyme/op12/master/"
let now = Date()
let eps = location
          .search
          .replace(/.*?(eps|episode|story)=(.*)(?=&|$)/gm, "$2")
let content = null
// タグの定義（タグ自身を処理の対象にする）
let arr_brkSlf = [
  {
    "before": "{",
    "after": "}",
    "replaceBefore": `<span class="curly-brks">`,
    "replaceAfter": `</span>`
  }
]
// タグの定義（タグと中身を処理の対象にする）
let arr_brkInc = [
  {
    "before": "[",
    "after": "]",
    "replaceBefore": `<span class="square-brks">`,
    "replaceAfter": `</span>`
  }
]
let prm_textSrc = null
let prm_tocSrc = null
let prm_text = null
let prm_toc = null
let opIdent = eps.replace(/(.*?)\d+\..*/, "$1")
let currIdent = eps.replace(/.*?(\d+)\..*/, "$1")
let extention = eps.replace(/.*(\..*)/, "$1")
let currNum = Number(currIdent)
let mode = null
if (eps !== "README.md" && eps !== "") {
  mode = 0
} else {
  mode = 1
}
/*

  実行

*/
// 本文が小説本文なら
if (mode === 0) {
  // 本文の処理
  prm_text = new Promise((resolve, reject) => {
    loadContent(backhost + eps + "?" + now)
    .then(async r => {
      if (r.ok) {
        prm_textSrc = r.text()
        return procBrk(await prm_textSrc)
      }
    })
    .then(r => {
      return parseRuby(r)
    })
    .then(r => {
      return removeMd(r)
    })
    .then(r => {
      return parseParagraph(r)
    })
    .then(r => {
      resolve(content = r)
    })
    .catch(() => {
      reject()
    })
  })
  // 目次の処理
  prm_toc = new Promise((resolve, reject) => {
    let w = null
    loadContent(backhost + "README.md?" + now)
    .then(async r => {
      if (r.ok) {
        prm_tocSrc = r.text()
        resolve(makeToc(await prm_tocSrc))
      }
    })
    .catch(() => {
      reject()
    })
  })
}
// 本文が README.md なら
else {
  // 本文の処理
  prm_text = new Promise((resolve, reject) => {
    loadContent(backhost + "README.md?" + now)
    .then(async r => {
      if (r.ok) {
        prm_tocSrc = r.text()
        return makeToc(await prm_tocSrc)
      }
    })
    .then(r => {
      resolve(procReadme(r))
    })
    .catch(() => {
      reject()
    })
  })
}
window.addEventListener("DOMContentLoaded", () => {
  let nod_text = document.querySelector("#text")
  let ndl_add = document.querySelectorAll(".addition")
  let ndl_toToc = document.querySelectorAll(".to-toc")
  let ndl_prev = document.querySelectorAll(".prev")
  let ndl_next = document.querySelectorAll(".next")
  let nod_len = document.querySelector("#length")
  // 本文の処理が終わったら
  prm_text
  .then(r => {
    // 本文を挿入
    nod_text.innerHTML = r
    // 本文が小説本文なら
    if (mode === 0) {
      // タイトルの表示
      prm_toc // <= 目次の処理が終わったら
      .then(r => {
        console.log()
        let nod_title = document.createElement("h1")
        nod_title.appendChild(document.createTextNode(r[currNum - 1][1]))
        nod_text.prepend(nod_title)
      })
      // 目次へのリンクの表示
      ndl_add.forEach(r => {
        r.classList.remove("hidden")
      })
      // 文字数の表示
      prm_textSrc
      .then(r => {
        procBrk(r)
        .then(r => {
          nod_len.textContent = `${removeRuby(r).replace(/[ \t　\r\n]/g, "").length} 文字`
        })
      })
    // 本文が README.md なら
    }
    else {
      let nod_toc = document.querySelector("#toc")
      nod_toc.style.width = nod_toc.getBoundingClientRect().width
      nod_toc.style.display = "block"
      prm_tocSrc
      .then(r => {
        let nod_title = document.createElement("h1")
        nod_title.appendChild(document.createTextNode(r.match(/# .*/)[0].replace(/# (.*)/, "$1")))
        nod_text.prepend(nod_title)
      })
    }
  })
  .catch(() => {
    nod_text.innerHTML = `<p style="text-align: center;">エラーが発生しました。申し訳ないことです。</p>`
  })
  // 本文が小説本文なら
  if (mode === 0) {
    // 目次の処理が終わったら
    prm_toc
    .then(r => {
      // リンクの設定
      setLink(r, ndl_toToc, ndl_prev, ndl_next)
    })
  }
})
/*

  関数

*/
// 本文の読み込み
function loadContent(url) {
  return fetch(url)
}
// ルビをパース
function parseRuby(src) {
  return src
         .replace(/｜([^｜]*?)《(.*?)》/g, `<ruby>$1<rt>$2</rt></ruby>`)
         .replace(/([\u4E00-\u9FFF]+)（(.*?)）/g, `<ruby>$1<rt>$2</rt></ruby>`)
         .replace(/｜(（.*?）)/g, "$1")
}
// ルビを削除
function removeRuby(src) {
  return src.replace(/｜([^｜]*?)《.*?》/g, "$1")
            .replace(/([\u4E00-\u9FFF]+)（(.*?)）/g, "$1")
            .replace(/｜(（.*?）)/g, "$1")
}// Markdown を削除
function removeMd(src) {
  return src
         .replace(/^[ \t]*[#*+\-_~=`>|].*\r?\n/gm, "")
}
// 段落の処理
function parseParagraph(src) {
  return src
         .replace(/(.+)\r?\n/g, "$1")
         .replace(/^(.*)$/gm, `<p>$1</p>`)
         .replace(/<p><\/p>/g, `<p><br></p>`)
}
// 括弧を処理 type=0 消去、tyep=1 色づけ
async function procBrk(src, type) {
  if (type === 1) {
    return markupInc(markupSelf(src))
  } else {
    return src.replace(rx_deleteSelf(), "").replace(rx_deleteInc(), "")
  }
  function rx_deleteSelf() {
    let w = ""
    let h = 0
    for (let i = 0; i < arr_brkSlf.length; i++) {
      w += esc(arr_brkSlf[i]["before"]) + esc(arr_brkSlf[i]["after"])
      h++
      if (h === arr_brkSlf.length) {
        return RegExp("[" + w + "]", "g")
      }
    }
  }
  function rx_deleteInc() {
    let w = ""
    let h = 0
    for (let i = 0; i < arr_brkInc.length; i++) {
      w += esc(arr_brkInc[i]["before"]) + ".*?" + esc(arr_brkInc[i]["after"]) + "|"
      h++
      if (h === arr_brkInc.length) {
        return RegExp("(" + w + ")", "g")
      }
    }
  }
  function markupSelf(r) {
    let g = 0
    let rx_brkBefore = RegExp(esc(arr_brkSlf[g]["before"]), "g")
    let rx_brkAfter = RegExp(esc(arr_brkSlf[g]["after"]), "g")
    let w = unEsc(r.replace(rx_brkBefore, arr_brkSlf[g]["replaceBefore"] + esc(arr_brkSlf[g]["before"]) + arr_brkSlf[g]["replaceAfter"]).replace(rx_brkAfter, arr_brkSlf[g]["replaceBefore"] + esc(arr_brkSlf[g]["after"]) + arr_brkSlf[g]["replaceAfter"]))
    g++
    if (g < arr_brkSlf.length) {
      markupSelf(w)
    } else {
      return w
    }
  }
  function markupInc(r) {
    let f = 0
    let rx_brk = RegExp(esc(arr_brkInc[f]["before"]) + "(.*?)" + esc(arr_brkInc[f]["after"]), "g")
    let w = unEsc(r.replace(rx_brk, arr_brkInc[f]["replaceBefore"] + esc(arr_brkInc[f]["before"]) + "$1" + esc(arr_brkInc[f]["after"]) + arr_brkInc[f]["replaceAfter"]))
    f++
    if (f < arr_brkInc.length) {
      markupInc(w)
    } else {
      return w
    }
  }
}
// README.md の処理
async function procReadme(arr_toc) {
  let arr_readme = []
  let sum = 0
  let arr_prm = []
  for (let i in arr_toc) {
    let prm = new Promise((resolve, reject) => {
      resolve(arr_readme[i] = `<li><a href="${arr_toc[i][2]}">${arr_toc[i][1]}</a></li>`)
    })
    arr_prm.push(prm)
  }
  return Promise.all(arr_prm)
  .then(r => {
    return `<ol id="toc">\n${r.join("\n")}\n</ol>`
  })
}
// 目次の作成
async function makeToc(src) {
  let w = src.replace(/(.*\r?\n)*(#+ 目次.*\r?\n)((.*\r?\n)*)#?/gm, "$3")
             .split(/\r?\n/)
             .filter(r => r !== "")
  for (let i in w) {
    w[i] = w[i].replace(/^(?:\*|\+|-|\d+\.) (.*)/, "$1")
               .split(/[ \t]*[:：][ \t]*/)
    if (w[i].length === 1) {
      w[i].push(w[i][0])
    }
  }
  w.map(r => r.push(linkBase + "?eps=" + r[0]))
  return await w
}
// 前の・次の作品へのリンクを表示する
function setLink(arr_toc, ndl_toToc, ndl_prev, ndl_next) {
  let prevFile = opIdent + ("0".repeat(currIdent.length) + (currNum - 1)).slice(-currIdent.length) + extention
  let nextFile = opIdent + ("0".repeat(currIdent.length) + (currNum + 1)).slice(-currIdent.length) + extention
  let arr_adjacentProc = {
    prev: async () => {
      ndl_prev.forEach(r => {
        r.href = `${linkBase}?eps=${prevFile}`
        r.innerHTML = `<< ${arr_toc[currNum - 2][1]}`
      })
    },
    next: async () => {
      ndl_next.forEach(r => {
        r.href = `${linkBase}?eps=${nextFile}`
        r.innerHTML = `${arr_toc[currNum][1]} >>`
      })
    }
  }
  if (
    currNum !== 1
    &&
    currNum !== arr_toc.length
  ) {
    arr_adjacentProc["prev"]()
    arr_adjacentProc["next"]()
  }
  else if (
    currNum !== 1
    &&
    arr_toc.length !== 1
  ) {
    arr_adjacentProc["prev"]()
  }
  else if (
    currNum === 1
    &&
    arr_toc.length >= 2
  ) {
    arr_adjacentProc["next"]()
  }
  ndl_toToc.forEach(r => {
    r.href = `${linkBase}?eps=README.md`
  })
}
// エスケープ
function esc(data) {
  return data
  .replace(/\//g, "\\/")
  .replace(/\\/g, "\\\\")
  .replace(/\^/g, "\\^")
  .replace(/\$/g, "\\$")
  .replace(/\*/g, "\\*")
  .replace(/\+/g, "\\+")
  .replace(/\?/g, "\\?")
  .replace(/\./g, "\\.")
  .replace(/\(/g, "\\(")
  .replace(/\[/g, "\\[")
}
// エスケープ解除
function unEsc(data) {
  return data
  .replace(/\\\//g, "/")
  .replace(/\\\\/g, "\\")
  .replace(/\\\^/g, "^")
  .replace(/\\\$/g, "$")
  .replace(/\\\*/g, "*")
  .replace(/\\\+/g, "+")
  .replace(/\\\?/g, "?")
  .replace(/\\\./g, ".")
  .replace(/\\\(/g, "(")
  .replace(/\\\[/g, "[")
}
</script>
<style>
/*

  一般的な設定

*/
body,
div {
  margin: 0;
  padding: 0;
}
h1 {
  margin-top: 0;
  margin-left: 0;
  margin-bottom: 0;
  font-size: 40px;
  font-weight: bold;
}
h2 {
  margin-top: 50px;
  margin-left: 15px;
  font-size: 30px;
  font-weight: bold;
}
/*

  固有の設定

*/
body {
  color: #222;
  background-color: #fff;
}
#frame {
  width: 600px;
  max-width: 95%;
  margin: auto;
}
#text {
  padding: 30px 0 50px 0;
  font-family: "メイリオ", "Meiryo", "Lucida Grande", "sans-serif";
}
#text p {
  margin: 0;
  padding: 0;
  font-size: 16px;
  line-height: 28.8px;
}
#text h1 + p {
  margin-top: 50px;
}
#text h1 {
  text-align: center;
}
#toc {
  display: inline-block;
  margin-top: 80px;
  margin-right: auto;
  margin-left: auto;
}
#toc li + li {
  margin-top: 10px;
}
.to-toc {
  text-align: center;
}
.addition {
  position: relative;
  width: 100%;
  text-align: center;
}
.addition.first {
  margin-top: 30px;
}
.addition.last {
  margin-bottom: 30px;
}
.addition a {
  display: inline-block;
  padding: 10px 5px 0 5px;
}
.addition.hidden {
  display: none;
}
.adjacent-box {
  display: inline-block;
  width: 49%;
  text-align: right;
}
.adjacent-box + .adjacent-box {
  text-align: left;
}
#length {
  line-height: 40px;
  vertical-align: bottom;
}
a,
a:visited,
a:hover {
  color: #62a433;
}
@media (prefers-color-scheme: dark) {
  body {
    color: #ccc;
    background-color: #111;
  }
}
@media print {
  html body {
    color: #222;
    background-color: #fff;
  }
  #frame {
    width: 100%;
  }
  #text {
    margin: 0;
    padding: 0;
    font-family: serif;
  }
  #text p {
    font-size: 18px;
    line-height: 36px;
  }
}
</style>
<div class="addition first hidden">
  <a class="to-toc">目次</a><br>
  <div class="adjacent-box">
    <a class="prev"></a>
  </div>
  <div class="adjacent-box">
    <a class="next"></a>
  </div>
  <span id="length"></span>
</div>
<div id="frame">
  <main id="text">
  </main>
</div>
<div class="addition last hidden">
  <div class="adjacent-box">
    <a class="prev"></a>
  </div>
  <div class="adjacent-box">
    <a class="next"></a>
  </div>
  <a class="to-toc hidden">目次</a>
</div>
</html>